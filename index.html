<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Live GPS Tracker Overlay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
  </style>
  <!--
    1) Replace YOUR_API_KEY with your Maps JavaScript API key
    2) The callback=initMap makes Maps call initMap() once loaded
  -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIfCWstMFLCiR9VJMS6lePKoytUgy1qPY=initMap"
    async defer>
  </script>
</head>
<body>
  <div id="map"></div>

  <script>
    // ─── CONFIG ─────────────────────────────────────────────────────────────
    const ENDPOINT        = 'https://script.google.com/macros/s/AKfycbzUuSXVnDgNVmR3lVH9X2ovAeahJnSWCe6oQXzxPGEefBCq-AL0pMMb853zApv7KNDa/exec';
    const INITIAL_ZOOM    = 13;
    const CENTER_FALLBACK = { lat: 36.3526, lng: -94.2755 };
    const REFRESH_MS      = 10000; // poll every 10s

    // ─── STATE ──────────────────────────────────────────────────────────────
    let map;
    const markers    = {};
    const trailPaths = {};

    // ─── INIT ───────────────────────────────────────────────────────────────
    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: CENTER_FALLBACK,
        zoom: INITIAL_ZOOM,
        mapTypeId: 'hybrid'
      });
      fetchData();
      setInterval(fetchData, REFRESH_MS);
    }

    // ─── FETCH & RENDER ─────────────────────────────────────────────────────
    async function fetchData() {
      try {
        const res    = await fetch(`${ENDPOINT}?json=true&t=${Date.now()}`);
        const points = await res.json();
        console.log('Fetched points:', points);

        if (!Array.isArray(points) || points.length === 0) {
          console.warn('No data returned.');
          return;
        }

        // Build per-device latest + full trail arrays
        const latest = {};
        const trails = {};
        points.forEach(pt => {
          const d = pt.device;
          const lat = parseFloat(pt.lat);
          const lng = parseFloat(pt.lon);
          if (!d || isNaN(lat) || isNaN(lng)) return;
          (trails[d]   = trails[d]   || []).push({ lat, lng });
          latest[d]    = { lat, lng };
        });

        // Update markers & polylines
        Object.keys(latest).forEach(d => {
          const pos = latest[d];
          // Marker
          if (markers[d]) {
            markers[d].setPosition(pos);
          } else {
            markers[d] = new google.maps.Marker({
              position: pos,
              map: map,
              title: d,
              icon: {
                url: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png',
                scaledSize: new google.maps.Size(40, 40),
                anchor: new google.maps.Point(20, 40),
                labelOrigin: new google.maps.Point(20, 0)
              },
              label: {
                text: d,
                color: '#fff',
                fontSize: '16px',
                fontWeight: 'bold'
              }
            });
          }
          // Trail
          if (trailPaths[d]) {
            trailPaths[d].setPath(trails[d]);
          } else {
            trailPaths[d] = new google.maps.Polyline({
              path: trails[d],
              geodesic: true,
              strokeColor: '#00BFFF',
              strokeOpacity: 0.8,
              strokeWeight: 4,
              map: map
            });
          }
        });

      } catch (err) {
        console.error('Error fetching data:', err);
      }
    }
  </script>
</body>
</html>


