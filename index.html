<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Live Angler Tracker with Full Trail</title>
  <meta name="viewport" content="initial-scale=1.0,user-scalable=no"/>
  <style>
    html, body, #map { margin:0; padding:0; width:100%; height:100%; }
    .map-control {
      background: #fff;
      border: 1px solid #000;
      margin: 10px;
      padding: 5px 10px;
      cursor: pointer;
      font-family: Arial, sans-serif;
      font-size: 14px;
    }
    .map-control.active {
      background: #007bff;
      color: #fff;
      border-color: #0056b3;
    }
  </style>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIfCWstMFLCiR9VJMS6lePKoytUgy1qPY"></script>
  <script src="https://unpkg.com/@googlemaps/markerclustererplus/dist/index.min.js"></script>
</head>
<body>
  <div id="map"></div>
  <script>
    const ENDPOINT        = 'https://script.google.com/macros/s/AKfycbzUuSXVnDgNVmR3lVH9X2ovAeahJnSWCe6oQXzxPGEefBCq-AL0pMMb853zApv7KNDa/exec';
    const INITIAL_ZOOM    = 12;
    const CENTER_FALLBACK = { lat: 36.3526, lng: -94.2755 };

    let map;
    let infoWindow;
    let firstLoad = true;

    // Full trail data
    const trailCoords = [];
    let trailPolyline = null;
    let trailVisible  = true;
    let toggleBtn;

    // Marker & cluster
    const markersArray = [];
    let markerCluster = null;

    async function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: CENTER_FALLBACK,
        zoom: INITIAL_ZOOM,
        mapTypeId: 'hybrid',
        disableDefaultUI: false,
        gestureHandling: 'greedy'
      });
      infoWindow = new google.maps.InfoWindow();

      // Add controls
      toggleBtn = createControl('Hide Trail', toggleTrail);
      toggleBtn.classList.add('active'); // trail shown by default
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(toggleBtn);
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(createControl('Fit Bounds', fitBounds));

      // Fetch and display historical trail
      await fetchInitialTrail();
      if (trailPolyline) {
        trailPolyline.setMap(map);
      }

      // Plot latest and then at intervals
      fetchAndPlot();
      setInterval(fetchAndPlot, 10000);
    }

    // Load all past points from sheet
    async function fetchInitialTrail() {
      try {
        // request up to 1000 records; adjust limit as needed
        const res = await fetch(`${ENDPOINT}?json=true&limit=1000&t=${Date.now()}`);
        const arr = await res.json();
        if (!arr.length) return;

        // sort ascending by timestamp
        arr.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        // build coords array
        arr.forEach(pt => {
          trailCoords.push({ lat: pt.latitude, lng: pt.longitude });
        });

        // create polyline but don't map until toggle
        trailPolyline = new google.maps.Polyline({
          path: trailCoords,
          geodesic: true,
          strokeColor: '#00F',
          strokeOpacity: 0.6,
          strokeWeight: 4
        });
      } catch (err) {
        console.error('Initial trail fetch error', err);
      }
    }

    function createControl(label, cb) {
      const div = document.createElement('div');
      div.className = 'map-control';
      div.textContent = label;
      div.addEventListener('click', cb);
      return div;
    }

    async function fetchAndPlot() {
      try {
        // fetch only the newest point
        const res = await fetch(`${ENDPOINT}?json=true&limit=1&t=${Date.now()}`);
        const arr = await res.json();
        if (!arr.length) return;
        const pt  = arr[0];
        const pos = { lat: pt.latitude, lng: pt.longitude };

        // append to trail coords and update polyline
        trailCoords.push(pos);
        if (trailPolyline) {
          trailPolyline.setPath(trailCoords);
        }

        // marker icon
        const icon = {
          url: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png',
          scaledSize: new google.maps.Size(48, 48),
          anchor: new google.maps.Point(24, 48),
          labelOrigin: new google.maps.Point(24, 0)
        };

        let marker;
        if (markersArray.length) {
          marker = markersArray[0];
          marker.setPosition(pos);
        } else {
          marker = new google.maps.Marker({
            position: pos,
            map,
            icon,
            label: { text: pt.device, color: '#fff', fontSize: '14px', fontWeight: 'bold' }
          });
          marker.addListener('click', () => showInfo(pt));
          markersArray.push(marker);
        }

        // update cluster
        if (!markerCluster) {
          markerCluster = new MarkerClusterer(map, markersArray, {
            imagePath: 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m'
          });
        } else {
          markerCluster.clearMarkers();
          markerCluster.addMarkers(markersArray);
        }

        // center on first load
        if (firstLoad) {
          map.setCenter(pos);
          map.setZoom(INITIAL_ZOOM);
          firstLoad = false;
        }
      } catch (err) {
        console.error('Fetch/plot error', err);
      }
    }

    function toggleTrail() {
      if (!trailPolyline) return;
      if (trailVisible) {
        trailPolyline.setMap(null);
        toggleBtn.textContent = 'Show Trail';
        toggleBtn.classList.remove('active');
      } else {
        trailPolyline.setMap(map);
        toggleBtn.textContent = 'Hide Trail';
        toggleBtn.classList.add('active');
      }
      trailVisible = !trailVisible;
    }

    function fitBounds() {
      if (!trailCoords.length && !markersArray.length) return;
      const bounds = new google.maps.LatLngBounds();
      // include all trail coords
      trailCoords.forEach(pt => bounds.extend(pt));
      // include marker positions too
      markersArray.forEach(m => bounds.extend(m.getPosition()));
      map.fitBounds(bounds);
    }

    function showInfo(pt) {
      const when = new Date(pt.timestamp).toLocaleString();
      let fishHtml = '';
      for (let fishType in pt.fishCaught) {
        fishHtml += `<div>${fishType}: ${pt.fishCaught[fishType]}</div>`;
      }
      const content = `
        <div style="font-size:14px; max-width:220px;">
          <strong>${pt.device}</strong><br>
          ${when}
          <hr style="margin:4px 0;">
          ${fishHtml}
        </div>`;
      infoWindow.setContent(content);
      infoWindow.open(map, markersArray[0]);
    }

    window.onload = initMap;
  </script>
</body>
</html>



